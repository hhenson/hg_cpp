HG_CPP TODO / Analysis Log
Updated: 2025-10-09 11:02
Owner: hg_cpp C++ runtime parity effort

Purpose
- Persist the high-level static review comparing the current C++ runtime implementation (and nanobind bindings) to the reference Python implementation in reference/hgraph/src.
- Serve as a working checklist and roadmap for bringing hg_cpp to feature parity and correctness.

Scope Reviewed
- Core time-series types: TS (scalar), TSL (list), TSS (set), TSD (dict), TSB (bundle), REF (references), TSW (window) [absent], TS signal.
- Builders (InputBuilder and typed/list/bundle/set/dict variants).
- Nodes and runtime engine skeleton (graph, evaluation engine API), nanobind exposure module.
- Python reference materials in reference/hgraph/src and tests under tests/python/hgraph_unit_tests.

High-level Findings
A. Implemented (C++ side exists; may be partial)
- TS (scalar value) via TimeSeriesValueInput/Output (include/hgraph/types/ts.h).
- TSL (list) via TimeSeriesList<Input/Output> (include/hgraph/types/tsl.h) with IndexedTimeSeries abstraction.
- TSB (bundle) and indexed infrastructure appear present via include/hgraph/types/ts_indexed.h and builders (list/bundle builders).
- REF implemented: TimeSeriesReference, Reference Input/Output, observer mechanics, nanobind registration hooks (include/hgraph/types/ref.h; src/cpp/types/ref.cpp exists).
- TS Signal Input present (include/hgraph/types/ts_signal.h) — by design, signal is input-only as a generic wrapper that exposes the ticked behaviour of the underlying output.
- Builders: InputBuilder plus concrete builders for TS value, list, bundle, set, dict, ref, signal (include/hgraph/builders/input_builder.h; src/cpp/builders/* present).
- Graph and runtime API skeleton: include/hgraph/types/graph.h, evaluation engine headers, scheduling interfaces.
- Python module entry: src/cpp/python/_hgraph_module.cpp registers utils, types, builders, runtime, nodes.

B. Missing or Not Evident
- TSW (Time Series Window) not found. Windowed computations (rolling/fixed windows) absent.
- Complete TSS (set) and TSD (dict) delta semantics: interfaces/builders exist, but underlying typed containers and delta/apply mechanics are not fully visible here; likely incomplete.
- TimeSeriesSignalOutput: not applicable by design; only the input exists (wrapper around underlying output's tick). Ensure docs/tests reflect this and binding pathways remain clear.
- Comprehensive node library parity with Python (operators, adaptors, runtime nodes) is incomplete/unclear.
- Full EvaluationEngine implementation and clock integration: interfaces present; internal logic and lifecycle correctness need verification.
- Reference lifecycle edge cases: observer registration/unregistration ownership, equality, and string forms are declared but correctness needs tests.
- Type equality across nested containers (e.g., list[dict[TS[int]]]) is only partially checked (e.g., TSL compares first element type when available); needs rigorous parity checks with Python’s schema system.

C. Divergences / Likely Bugs or Behavior Differences
- TimeSeriesSignalInput::is_same_type returns true unconditionally; may cause mismatched bindings to be accepted.
- TimeSeriesList is_same_type compares only first element when both non-empty; empty lists treated as compatible, which may mask type mismatches compared to Python schema validation.
- REF observer set uses raw TimeSeriesInput* with manual lifetime management due to missing hash on ptr — fragile; ensure increments/decrements and de-duplication are correct.
- TimeSeriesValueOutput<T>::apply_result silently ignores None; may differ from Python where explicit invalidation or delta None semantics are defined.
- Copy semantics across Input/Output (copy_from_input/output) rely on dynamic_cast and assume exact type; mixed subtype scenarios may fail noisily.
- Graph scheduling details (push_source_nodes_end, schedule vector, force_set semantics) need alignment with Python engine behavior (e.g., event coalescing, priority, time ordering).

D. Testing Gaps
- No evident C++-side unit tests mirroring the rich Python test suite for types, deltas, and engine lifecycle.
- Nanobind exposure coverage: ensure all new types are exported and constructor/builder paths are available to Python tests.

Prioritized Action Plan
1. Establish minimal type parity for pipelines to run
   - Document/validate Signal design (no dedicated Output): ensure SignalInput binds to existing outputs correctly and delta semantics (py_value/py_delta_value) match Python.
   - Verify TS (scalar) and TSL (list) end-to-end: py_value/py_delta_value, modified/valid flags, copy_from_* behavior. 
   - Implement stricter is_same_type for Signal and List (handle empty collections with schema hints), or document intentional divergence.
2. Implement/confirm TSD (dict) and TSS (set) concrete containers
   - Ensure delta representation and application align with Python (added/removed/modified keys and items ordering). 
   - Provide iterators, items(), keys(), modified/valid queries consistent with reference.
3. Reference (REF) lifecycle correctness
   - Harden observer registration/unregistration; ensure no dangling raw pointers. 
   - Define equality and to_string parity with Python. 
   - Add tests for binding/unbinding, cloning bindings, nested refs (lists/bundles of refs).
4. Windowed series (TSW)
   - Design and implement TSW core types with window policies (size-by-count/interval) and delta/valid semantics matching Python. 
   - Defer if not needed for initial runnable graphs, but track as parity blocker.
5. Engine lifecycle and scheduling
   - Validate Graph initialisation/start/stop/dispose hooks; confirm evaluation_clock and engine_clock behaviors. 
   - Define schedule_node semantics (force_set), event ordering, and push_source_nodes_end consistency with reference engine.
6. Type system rigor and schemas
   - Improve is_same_type across nested container builders and types; avoid first-element-only heuristics where possible. 
   - Ensure builders’ is_same_type mirrors Python’s schema comparisons.
7. Nanobind coverage & API hygiene
   - Register all missing types/builders in export_types/export_builders; ensure reference and container types expose needed methods to Python. 
   - Add docstrings where helpful.
8. Testing strategy
   - Leverage Python tests in tests/python/hgraph_unit_tests by running against C++ runtime where applicable. 
   - Add targeted C++ unit tests for low-level type semantics (modified/valid flags, deltas, copy semantics, ref observers). 
   - Introduce minimal CI recipes to build and run these tests.

Notes/Risks
- Using raw pointers in REF observer set is a short-term workaround; consider custom hash for nb::ref or stable ids. 
- Empty collection type compatibility is convenient but risky; introduce schema hints or enforce stricter checks in builders. 
- Aligning delta semantics (especially for dict/set) is critical for incremental evaluation correctness.

Next Immediate Steps (suggested for upcoming iteration)
- Document/validate Signal design (no dedicated Output); tighten is_same_type for signals if needed; ensure nanobind exposure/docs are clear. 
- Write focused tests: TS/TSL values and deltas; REF observer lifecycle. 
- Review and, if needed, adjust TimeSeriesList is_same_type and items()/modified_items() behavior to match Python semantics.
